<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Solver LP ‚Äî Texto/Archivo/Imagen (PDF+OCR) ‚Ä¢ Simplex + Duales</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Libs puramente de front (sin workers externos obligatorios) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.1/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
  <!-- OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.4/dist/tesseract.min.js"></script>
  <!-- pdf.js (usaremos disableWorker=true para evitar importScripts) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <!-- Lectores de archivos opcionales (no usan worker) -->
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    :root{--bg:#f7f8fb;--fg:#222;--card:#fff;--pri:#4e73df;--pri-d:#2e59d9;--muted:#667085}
    *{box-sizing:border-box}
    body{margin:0;padding:24px;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--fg)}
    h2,h3{color:var(--pri);margin:0 0 8px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    @media (max-width:1000px){.grid{grid-template-columns:1fr}}
    .card{background:var(--card);border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.06);padding:16px}
    textarea{width:100%;min-height:180px;border:1px solid #e5e7eb;border-radius:10px;padding:12px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .btn{appearance:none;border:none;border-radius:10px;background:var(--pri);color:#fff;font-weight:600;padding:10px 14px;cursor:pointer}
    .btn:hover{background:var(--pri-d)}
    .btn.secondary{background:#858796}.btn.secondary:hover{background:#6c757d}
    .pill{background:#eef2ff;color:#1e293b;padding:6px 10px;border-radius:999px;font-size:12px}
    .drop{border:2px dashed #cbd5e1;border-radius:12px;padding:16px;text-align:center;background:#fafafa;color:#475569}
    .drop.drag{background:#eef2ff;border-color:var(--pri)}
    .muted{color:var(--muted)}
    .loading{border:4px solid #f3f3f3;border-top:4px solid #3498db;border-radius:50%;width:26px;height:26px;animation:spin 1s linear infinite;margin:10px auto}
    @keyframes spin{to{transform:rotate(360deg)}}
    table{width:100%;border-collapse:collapse;margin-top:8px;font-size:14px}
    th,td{border:1px solid #e5e7eb;padding:6px 8px;text-align:center}
    th{background:#f8fafc}
    .ok{background:#e8f5e9;color:#1b5e20;padding:10px;border-radius:10px;margin:10px 0}
    .warn{background:#fff8e1;color:#8d6e00;padding:10px;border-radius:10px;margin:10px 0}
    .err{background:#fdecea;color:#b71c1c;padding:10px;border-radius:10px;margin:10px 0}
    details{margin-top:8px}
    .graph{width:100%;height:420px}
  </style>
</head>
<body>
  <h2>üîç Solver LP ‚Äî Carga de Archivos, PDF, Im√°genes (OCR) y Texto</h2>
  <p class="muted">Resuelve Programaci√≥n Lineal (LP) a partir de texto, .lp, .mps, PDF o imagen. Sin workers externos (PDF en modo seguro, OCR integrado).</p>

  <div class="grid">
    <div class="card">
      <h3>1) Cargar archivo o pegar enunciado</h3>
      <div id="drop" class="drop">Arrastra archivos aqu√≠ o
        <label style="text-decoration:underline;cursor:pointer;color:#2563eb">
          <input id="file" type="file" multiple style="display:none"
                 accept=".txt,.lp,.mps,.csv,.xlsx,.xls,.json,.md,.html,.pdf,.png,.jpg,.jpeg,.webp,.docx" />
          selecci√≥nalos
        </label>
      </div>
      <div class="row" style="margin-top:8px">
        <span class="pill">Formatos: txt, lp, mps, pdf, png/jpg, docx, xlsx/csv, json, md, html</span>
        <button class="btn secondary" id="limpiar">Limpiar</button>
      </div>
      <h3 style="margin-top:12px">o pega el enunciado</h3>
      <textarea id="entrada" placeholder="Ej.: Z = 80x + 50y; 4x + 3y ‚â§ 240; 2x + y ‚â§ 100; x,y ‚â• 0"></textarea>
      <div class="row" style="margin-top:8px">
        <button class="btn" id="btn-analizar">Analizar y resolver</button>
        <button class="btn secondary" id="btn-tests">Pruebas autom√°ticas</button>
      </div>
      <div id="archivos" class="muted" style="margin-top:6px"></div>
      <div id="log" class="muted" style="margin-top:6px;white-space:pre-wrap"></div>
    </div>

    <div class="card">
      <h3>2) Interpretaci√≥n</h3>
      <div id="interpretacion" class="muted">Aqu√≠ ver√°s el modelo detectado.</div>
    </div>
  </div>

  <div class="card" style="margin-top:16px">
    <h3>3) Resultados</h3>
    <div id="resultados" class="muted">Aqu√≠ aparecer√°n soluciones, duales, slacks y gr√°ficos.</div>
  </div>

<script>
/* ===========================
   0) PDF.js modo seguro (sin worker)
   =========================== */
pdfjsLib.GlobalWorkerOptions.workerSrc = null;
pdfjsLib.disableWorker = true;

/* ===========================
   1) Utilidades de UI
   =========================== */
const $ = s => document.querySelector(s);
const byId = id => document.getElementById(id);
const logArea = byId('log');
function log(msg){ logArea.textContent += (logArea.textContent? '\n':'') + msg; }

/* ===========================
   2) Carga de archivos (incluye OCR y PDF)
   =========================== */
const fileInput = byId('file');
const drop = byId('drop');
const entrada = byId('entrada');
const archivos = byId('archivos');

drop.addEventListener('click', ()=> fileInput.click());
['dragenter','dragover'].forEach(evt => drop.addEventListener(evt, e=>{
  e.preventDefault(); e.stopPropagation(); drop.classList.add('drag');
}));
['dragleave','drop'].forEach(evt => drop.addEventListener(evt, e=>{
  e.preventDefault(); e.stopPropagation(); drop.classList.remove('drag');
}));
drop.addEventListener('drop', e => handleFiles(e.dataTransfer.files));
fileInput.addEventListener('change', e => handleFiles(e.target.files));
byId('limpiar').addEventListener('click', ()=>{
  entrada.value = ''; archivos.textContent=''; logArea.textContent='';
  byId('interpretacion').textContent=''; byId('resultados').textContent='';
});

async function handleFiles(fileList){
  const files = Array.from(fileList||[]);
  if(!files.length) return;
  archivos.textContent = files.map(f=>‚Ä¢ ${f.name} (${(f.size/1024).toFixed(1)} KB)).join('\n');
  let bloques = [];
  for(const file of files){
    try{
      const txt = await leerArchivo(file);
      if(txt && txt.trim()) bloques.push(\n---\n# ${file.name}\n\n${txt.trim()});
    }catch(err){
      log(Error leyendo ${file.name}: ${err.message});
      bloques.push(\n---\n# ${file.name}\n\n[Error al leer: ${err.message}]);
    }
  }
  entrada.value = (entrada.value + '\n' + bloques.join('\n')).trim();
}

function asText(file){
  return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsText(file,'utf-8'); });
}
function asArrayBuffer(file){
  return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsArrayBuffer(file); });
}
async function leerArchivo(file){
  const ext = (file.name.split('.').pop()||'').toLowerCase();
  if(['txt','md','html','json','csv','lp','mps'].includes(ext)){
    const raw = await asText(file);
    if(ext==='json'){ try{ return extraerDeJSON(JSON.parse(raw)); }catch{return raw;} }
    if(ext==='csv'){ const p = Papa.parse(raw, {skipEmptyLines:true}); return p.data.map(r=>r.join('\t')).join('\n'); }
    return raw;
  }
  if(ext==='docx'){
    const buf = await asArrayBuffer(file);
    const { value } = await mammoth.extractRawText({arrayBuffer:buf});
    return value;
  }
  if(ext==='xlsx' || ext==='xls'){
    const buf = await asArrayBuffer(file);
    const wb = XLSX.read(buf, {type:'array'});
    let out=[]; wb.SheetNames.forEach(n=>{
      const sh = wb.Sheets[n]; out.push(## Hoja: ${n}\n+XLSX.utils.sheet_to_csv(sh));
    }); return out.join('\n');
  }
  if(ext==='pdf'){
    const buf = await asArrayBuffer(file);
    return await extraerTextoPDF(buf);
  }
  if(['png','jpg','jpeg','webp'].includes(ext)){
    const url = URL.createObjectURL(file);
    return await ocrImagen(url);
  }
  // Fallback gen√©rico
  return asText(file);
}
function extraerDeJSON(obj){
  if(typeof obj==='string') return obj;
  if(Array.isArray(obj)) return obj.map(extraerDeJSON).join('\n');
  if(obj && typeof obj==='object') return Object.entries(obj).map(([k,v])=># ${k}\n${extraerDeJSON(v)}).join('\n');
  return String(obj);
}
async function extraerTextoPDF(arrayBuffer){
  try{
    const pdf = await pdfjsLib.getDocument({data:arrayBuffer}).promise;
    let full=''; 
    for(let p=1; p<=pdf.numPages; p++){
      const page = await pdf.getPage(p);
      const content = await page.getTextContent();
      full += '\n' + content.items.map(it=>it.str).join(' ');
    }
    return full;
  }catch(err){
    log('PDF error (modo sin worker): '+err.message);
    throw err;
  }
}
async function ocrImagen(objectURL){
  try{
    const { data:{ text } } = await Tesseract.recognize(objectURL, 'spa+eng', {
      logger: m => {/* opcional: progreso */ }
    });
    return text || '';
  }catch(err){
    log('OCR error: '+err.message);
    throw err;
  }
}

/* ===========================
   3) Parseo universal (texto libre / .lp / .mps)
   =========================== */
function esc(s){ return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }
function normNum(str){
  // normaliza "1.000,50" o "1,000.50" a "1000.50"
  const s = String(str).trim();
  // si hay coma y punto, asume formato local -> elimina separadores de miles
  if(/[.,]/.test(s)){
    // heur√≠stica: √∫ltimo separador como decimal
    const last = Math.max(s.lastIndexOf(','), s.lastIndexOf('.'));
    const head = s.slice(0,last).replace(/[.,]/g,'');
    const dec = s.slice(last+1);
    if(last>0) return Number(${head}.${dec});
  }
  return Number(s.replace(/,/g,''));
}
function parseTextoLibre(texto){
  // acepta: "Z = ax + by", y N variables "Z = 3x1 + 2x2 + ..."
  // restricciones con <=, >=, =, tambi√©n s√≠mbolos ‚â§ ‚â•; no negatividad si se menciona
  const t = texto.replace(/[‚Äî‚Äì]/g,'-').replace(/‚â§/g,'<=').replace(/‚â•/g,'>=');
  const lines = t.split(/\n|;/).map(s=>s.trim()).filter(Boolean);

  // Objetivo
  // Si no se especifica Max/Min, por defecto MAX
  let sense = /min(?:imizar|imize)?/i.test(t)? 'min' : 'max';
  let c = {}, vars = new Set();
  const objMatch = t.match(/(?:^|\b)(?:z|obj|objetivo|objective)\s*[:=]\s*([^;\n]+)/i)
                || t.match(/(?:^|\b)(?:max(?:imizar)?|min(?:imizar)?)[^:\n][:=]?\s([^;\n]+)/i);
  if(objMatch){
    const expr = objMatch[1];
    const terms = expr.match(/[+\-]?\s*\d*(?:[.,]\d+)?\s*\?\s[a-zA-Z]\w*/g) || [];
    terms.forEach(tok=>{
      const m = tok.match(/([+\-]?\s*\d*(?:[.,]\d+)?)\s*\?\s([a-zA-Z]\w*)/);
      if(m){
        const coef = m[1].trim()===''||m[1].trim()==='+'? 1 :
                     m[1].trim()==='-'? -1 : normNum(m[1]);
        const v = m[2];
        c[v] = (c[v]||0) + coef;
        vars.add(v);
      }
    });
  }
  // Restricciones
  const cons = [];
  for(const ln of lines){
    const m = ln.match(/^(.+?)\s*(<=|>=|==|=)\s*([+\-]?\d+(?:[.,]\d+)?)\s*$/);
    if(!m) continue;
    const LHS = m[1], sgn = m[2]==='='?'==':m[2], rhs = normNum(m[3]);
    const row = {};
    const terms = LHS.match(/[+\-]?\s*\d*(?:[.,]\d+)?\s*\?\s[a-zA-Z]\w*/g) || [];
    terms.forEach(tok=>{
      const mm = tok.match(/([+\-]?\s*\d*(?:[.,]\d+)?)\s*\?\s([a-zA-Z]\w*)/);
      if(mm){
        const coef = mm[1].trim()===''||mm[1].trim()==='+'? 1 :
                     mm[1].trim()==='-'? -1 : normNum(mm[1]);
        const v = mm[2];
        row[v] = (row[v]||0) + coef;
        vars.add(v);
      }
    });
    if(Object.keys(row).length) cons.push({row, sign: sgn, rhs});
  }
  // Bounds simples por menciones de no negatividad
  const bounds = {};
  if(/(?:\b|,)\s*(?:x|y|[a-z]\w*(?:\s*,\s*[a-z]\w*))\s>=?\s*0/i.test(t) || /no\s*negativ/i.test(t)){
    vars.forEach(v=> bounds[v] = {lb:0});
  }
  // matriz en orden consistente
  const V = Array.from(vars);
  const cvec = V.map(v=> c[v]||0);
  const A = cons.map(con=>{
    const row = V.map(v=> con.row[v]||0);
    return {...con, rowArr: row};
  });
  return {sense, V, cvec, A, bounds};
}

// Parser LP simple (secciones Maximize/Minimize, Subject To, Bounds, Binary/General)
function parseLP(raw){
  const t = raw.replace(/\r/g,'');
  let sense = /minimize/i.test(t)? 'min' : 'max';
  const objSec = t.match(/(?:maximize|minimize)\s*(.*?)\s*subject\s*to/is)
               || t.match(/(?:maximize|minimize)\s*(.?)\s(?:bounds|binary|general|end)/is);
  const Vset = new Set(); const c = {};
  if(objSec){
    const expr = objSec[1].replace(/\s+/g,' ');
    const terms = expr.match(/[+\-]?\s*\d*(?:\.\d+)?\s*\?\s[a-zA-Z]\w*/g)||[];
    terms.forEach(tok=>{
      const m = tok.match(/([+\-]?\s*\d*(?:\.\d+)?)\s*\?\s([a-zA-Z]\w*)/);
      if(m){ const coef = m[1].trim()===''||m[1]==='+'?1 : m[1]==='-'?-1: Number(m[1]); c[m[2]]=(c[m[2]]||0)+coef; Vset.add(m[2]); }
    });
  }
  // restricciones
  const st = t.split(/subject\s*to/i)[1] || '';
  const tail = st.split(/bounds|binary|general|end/i)[0] || '';
  const lines = tail.split(/\n|;/).map(s=>s.trim()).filter(Boolean);
  const cons=[]; lines.forEach(ln=>{
    const m = ln.match(/(.+?)\s*(<=|>=|=)\s*([+\-]?\d+(?:\.\d+)?)/i);
    if(!m) return;
    const LHS=m[1], sgn=m[2]==='='?'==':m[2], rhs=Number(m[3]);
    const row={}; const terms = LHS.match(/[+\-]?\s*\d*(?:\.\d+)?\s*\?\s[a-zA-Z]\w*/g)||[];
    terms.forEach(tok=>{ const mm=tok.match(/([+\-]?\s*\d*(?:\.\d+)?)\s*\?\s([a-zA-Z]\w*)/);
      if(mm){ const v=mm[2], coef=mm[1].trim()===''||mm[1]==='+'?1:mm[1]==='-'?-1:Number(mm[1]); row[v]=(row[v]||0)+coef; Vset.add(v); }
    });
    cons.push({row, sign: sgn, rhs});
  });
  // bounds (b√°sico)
  const boundsTxt = (t.split(/bounds/i)[1]||'').split(/binary|general|end/i)[0]||'';
  const bounds={};
  boundsTxt.split(/\n|;/).map(s=>s.trim()).filter(Boolean).forEach(ln=>{
    // 0 <= x <= 5  |  x >= 0  |  x free
    let m = ln.match(/([+\-]?\d+(?:\.\d+)?)\s*<=\s*([a-zA-Z]\w*)\s*<=\s*([+\-]?\d+(?:\.\d+)?)/i);
    if(m){ const v=m[2]; bounds[v]={lb:Number(m[1]), ub:Number(m[3])}; return; }
    m = ln.match(/([a-zA-Z]\w*)\s*>=\s*([+\-]?\d+(?:\.\d+)?)/i);
    if(m){ const v=m[1]; bounds[v]={...(bounds[v]||{}), lb:Number(m[2])}; return; }
    m = ln.match(/([a-zA-Z]\w*)\s*<=\s*([+\-]?\d+(?:\.\d+)?)/i);
    if(m){ const v=m[1]; bounds[v]={...(bounds[v]||{}), ub:Number(m[2])}; return; }
    m = ln.match(/([a-zA-Z]\w*)\s+free/i);
    if(m){ const v=m[1]; bounds[v]={lb:-Infinity, ub:Infinity}; return; }
  });
  const V = Array.from(Vset);
  const cvec = V.map(v=> c[v]||0);
  const A = cons.map(con=> ({...con, rowArr: V.map(v=> con.row[v]||0)}));
  return {sense, V, cvec, A, bounds};
}

// Parser MPS (free-form b√°sico)
function parseMPS(raw){
  const t = raw.replace(/\r/g,'');
  const lines = t.split('\n');
  const rows=[], cols=[], rhs=[], bnds=[];
  let sec='';
  lines.forEach(L=>{
    const ln = L.trim();
    if(!ln) return;
    if(/^(name|rows|columns|rhs|bounds|endata)/i.test(ln)){ sec=ln.split(/\s+/)[0].toUpperCase(); return; }
    if(sec==='ROWS') rows.push(ln);
    else if(sec==='COLUMNS') cols.push(ln);
    else if(sec==='RHS') rhs.push(ln);
    else if(sec==='BOUNDS') bnds.push(ln);
  });
  const rowType={}, rowIdx={}; let objRow=null;
  rows.forEach(r=>{
    const m = r.match(/^([NLG E])\s+(\S+)/i);
    if(m){ const t=m[1].trim().toUpperCase(), name=m[2]; rowType[name]=t; rowIdx[name]=Object.keys(rowIdx).length; if(t==='N') objRow=name; }
  });
  const Vset = new Set(), Amap={}; // Amap[row][col]=coef
  cols.forEach(c=>{
    // col row val [row val]
    const m = c.trim().split(/\s+/);
    if(m.length>=3){
      const col = m[0], r1=m[1], v1=parseFloat(m[2]);
      Vset.add(col);
      Amap[r1] = Amap[r1]||{}; Amap[r1][col]=(Amap[r1][col]||0)+v1;
      if(m.length>=5){ const r2=m[3], v2=parseFloat(m[4]); Amap[r2]=Amap[r2]||{}; Amap[r2][col]=(Amap[r2][col]||0)+v2; }
    }
  });
  let RHS={};
  rhs.forEach(r=>{
    const m = r.trim().split(/\s+/);
    if(m.length>=3){ const row=m[1], v=parseFloat(m[2]); RHS[row]=v; }
    if(m.length>=5){ const row2=m[3], v2=parseFloat(m[4]); RHS[row2]=v2; }
  });
  const cons=[];
  Object.keys(rowType).forEach(r=>{
    if(r===objRow) return;
    const typ=rowType[r]; const sign = typ==='L'?'<=': typ==='G'?'>=':'==';
    const row=Amap[r]||{};
    cons.push({row, sign, rhs: RHS[r]||0});
  });
  // objetivo
  const c={};
  const obj = Amap[objRow]||{};
  Object.keys(obj).forEach(v=> c[v]=(c[v]||0)+obj[v]);
  const V = Array.from(Vset);
  const cvec = V.map(v=> c[v]||0);
  const A = cons.map(con=> ({...con, rowArr: V.map(v=> con.row[v]||0)}));
  return {sense:'min', V, cvec, A, bounds:{}};
}

function parseUniversal(texto){
  const lower = texto.toLowerCase();
  if(/\bmax(?:imize|imizar)?\b|\bmin(?:imize|imizar)?\b/.test(lower) && /subject\s*to/i.test(texto)){
    return parseLP(texto);
  }
  if(/^name\b|\brows\b|\bcolumns\b|\brhs\b|\bbounds\b|\bendata\b/i.test(texto)){
    return parseMPS(texto);
  }
  return parseTextoLibre(texto);
}

/* ===========================
   4) Solver Simplex (Fase I/II) + Duales/Reducidos (LP)
   =========================== */
function simplexSolve(model){
  // model: {sense, V, cvec, A[{rowArr, sign, rhs}], bounds{v:{lb,ub}}}
  // Convertir a est√°ndar con holguras/excesos y artificiales
  const n = model.V.length, m = model.A.length;
  const c = model.cvec.slice();
  const isMax = model.sense==='max';
  const toMinC = isMax ? c.map(x=> -x) : c.slice();

  // construir tableau
  // Filas de restricciones ‚Üí <= con holgura; >= y == con artificial
  let rows=[]; let basis=[];
  let artCols=0;
  for(let i=0;i<m;i++){
    const {rowArr, sign, rhs} = model.A[i];
    let row = new Array(n).fill(0).map((_,j)=> rowArr[j]||0);
    // Slack/Exceso
    const slack = new Array(m).fill(0);
    const art = new Array(m).fill(0);
    if(sign==='<='){ slack[i]=1; }
    else if(sign==='>='){ slack[i]=-1; art[i]=1; artCols++; }
    else if(sign==='=='){ art[i]=1; artCols++; }
    // ensamblar: [x..., slack m..., art m..., RHS]
    row = [...row, ...slack, ...art, rhs];
    rows.push(row);
    // base inicial
    if(sign==='<=') basis.push(n+i); else basis.push(n+m+i); // slack o artificial
  }
  const totalCols = n + m + m; // x + slack + art
  // Fase I
  let T = rows.map(r=>{
    const row = new Array(totalCols+1).fill(0);
    for(let j=0;j<r.length;j++) row[j]=r[j];
    return row;
  });
  let obj1 = new Array(totalCols+1).fill(0);
  for(let i=0;i<m;i++){
    if(basis[i]===n+m+i){ // artificial en base
      for(let j=0;j<=totalCols;j++) obj1[j] += T[i][j];
    }
  }
  obj1 = obj1.map(v=> -v); // minimizar
  T.unshift(obj1);
  simplexCore(T, basis);
  if(Math.abs(T[0][totalCols])>1e-8) return {error:'Infactible (Fase I > 0).'};
  // preparar Fase II
  // quitar contribuci√≥n artificial del objetivo original
  const obj2 = new Array(totalCols+1).fill(0);
  for(let j=0;j<n;j++) obj2[j] = toMinC[j]||0;
  T[0] = obj2;
  for(let i=1;i<T.length;i++){
    const bj = basis[i-1];
    const factor = T[0][bj];
    if(Math.abs(factor)>1e-12){
      for(let j=0;j<=totalCols;j++) T[0][j] -= factor * T[i][j];
    }
  }
  simplexCore(T, basis);

  // extraer soluci√≥n
  const sol = new Array(n).fill(0);
  const RHS = totalCols;
  for(let i=1;i<T.length;i++){
    const bj = basis[i-1];
    if(bj < n) sol[bj] = T[i][RHS];
  }
  const Z = isMax ? -T[0][RHS] : T[0][RHS];

  // slacks/excesos
  const slackVals = new Array(m).fill(0);
  for(let i=1;i<T.length;i++){
    const bj = basis[i-1];
    if(bj>=n && bj<n+m) slackVals[bj-n] = T[i][RHS];
  }

  // Precios duales y costos reducidos (v√°lidos para LP)
  // y^T = c_B^T B^{-1}. Reconstruimos B de columnas b√°sicas.
  const B = [];
  const cB = [];
  for(let i=0;i<m;i++){
    const bj = basis[i];
    const col = [];
    for(let r=1; r<T.length; r++) col.push(T[r][bj]);
    B.push(col);
    cB.push( (bj<n)? toMinC[bj] : 0 ); // contribuci√≥n original para x; slack tiene costo 0
  }
  // Invertir B
  function inv(mat){
    const n=mat.length;
    const A=mat.map(r=>r.slice());
    const I=Array.from({length:n},(,i)=> Array.from({length:n},(_,j)=> i===j?1:0));
    for(let i=0;i<n;i++){
      let piv=i;
      for(let r=i;r<n;r++) if(Math.abs(A[r][i])>Math.abs(A[piv][i])) piv=r;
      if(Math.abs(A[piv][i])<1e-12) throw new Error('B no invertible');
      [A[i],A[piv]]=[A[piv],A[i]]; [I[i],I[piv]]=[I[piv],I[i]];
      const p=A[i][i];
      for(let j=0;j<n;j++){ A[i][j]/=p; I[i][j]/=p; }
      for(let r=0;r<n;r++) if(r!==i){
        const f=A[r][i];
        for(let j=0;j<n;j++){ A[r][j]-=f*A[i][j]; I[r][j]-=f*I[i][j]; }
      }
    }
    return I;
  }
  let yT = null, reduced = null;
  try{
    const Binv = inv(B);
    // y^T = c_B^T B^{-1}
    yT = new Array(m).fill(0);
    for(let j=0;j<m;j++){
      for(let k=0;k<m;k++) yT[j] += cB[k]*Binv[k][j];
    }
    // costos reducidos r_j = c_j - y^T * A_j  (en el espacio ‚Äúa la Fase II‚Äù original)
    reduced = new Array(n).fill(0);
    for(let j=0;j<n;j++){
      // construir columna A_j desde restricciones originales (sin slacks/art)
      const Aj = model.A.map(con=> con.rowArr[j]||0);
      let yTA=0; for(let k=0;k<m;k++) yTA += yT[k]*Aj[k];
      reduced[j] = toMinC[j] - yTA;  // si sense=max, recuerda que toMinC = -c
      if(isMax) reduced[j] = -reduced[j]; // reportar en convenci√≥n del usuario
    }
    // precios duales, reportados en convenci√≥n del usuario: si es max, y corresponde a dual de <=
    if(isMax){ yT = yT.map(v=> -v); } // para presentar sombra intuitiva (incremento en RHS)
  }catch(_e){
    // si B no invertible por degeneraci√≥n, omitimos duales
  }

  return {optimalValue: Z, x: sol, slack: slackVals, dual: yT, reduced, basis, tableau:T, isMax};
}

// n√∫cleo pivoteo (regla de Bland para evitar ciclos)
function simplexCore(T, basis){
  const rows = T.length, cols=T[0].length, RHS=cols-1;
  let iter=0;
  while(iter++<2000){
    // elegir columna pivote: coef m√°s negativo en Z (evitar ties con Bland)
    let pc=-1, min=0;
    for(let j=0;j<RHS;j++){
      const v=T[0][j];
      if(v<min - 1e-12){ min=v; pc=j; break; } // Bland: el primero que cumpla
    }
    if(pc===-1) break; // √≥ptimo
    // fila pivote: m√≠nima raz√≥n positiva
    let pr=-1, best=Infinity;
    for(let i=1;i<rows;i++){
      const a=T[i][pc];
      if(a>1e-12){
        const r=T[i][RHS]/a;
        if(r<best - 1e-12){ best=r; pr=i; }
      }
    }
    if(pr===-1) throw new Error('No acotado');
    // pivotear
    const piv=T[pr][pc];
    for(let j=0;j<cols;j++) T[pr][j]/=piv;
    for(let i=0;i<rows;i++){
      if(i===pr) continue;
      const f=T[i][pc];
      if(Math.abs(f)>1e-12) for(let j=0;j<cols;j++) T[i][j]-=f*T[pr][j];
    }
    basis[pr-1]=pc;
  }
}

/* ===========================
   5) Render de interpretaci√≥n y resultados + gr√°ficos
   =========================== */
function renderInterpretacion(model){
  let h = '';
  h += <div><b>${model.sense==='min'?'Minimizaci√≥n':'Maximizaci√≥n'}</b> ‚Äî Objetivo con ${model.V.length} variable(s)</div>;
  h += <div class="pill">Variables: ${model.V.join(', ')}</div>;
  if(model.A.length){
    h += <table><tr><th>#</th><th>Restricci√≥n</th></tr>;
    model.A.forEach((r,i)=>{
      const expr = model.V.map((v,j)=> r.rowArr[j]? ${fmt(r.rowArr[j])}${v}:'' ).filter(Boolean).join(' + ');
      h += <tr><td>${i+1}</td><td>${expr} ${r.sign.replace('==','=')} ${fmt(r.rhs)}</td></tr>;
    });
    h += </table>;
  } else {
    h += <div class="warn">No se detectaron restricciones.</div>;
  }
  byId('interpretacion').innerHTML = h;
}
function fmt(n){ return (Math.abs(n)%1>1e-9)? Number(n).toFixed(6) : Number(n).toString(); }

function renderResultados(model, sol){
  if(sol.error){ byId('resultados').innerHTML = <div class="err">${sol.error}</div>; return; }
  let h = <div class="ok">‚úÖ ${model.sense==='min'?'Valor m√≠nimo':'Valor m√°ximo'}: <b>${fmt(sol.optimalValue)}</b></div>;
  h += <h4>Variables</h4><table><tr><th>Variable</th><th>Valor</th><th>Costo reducido (LP)</th></tr>;
  model.V.forEach((v,i)=>{
    h += <tr><td>${v}</td><td>${fmt(sol.x[i]||0)}</td><td>${sol.reduced? fmt(sol.reduced[i]): '-'}</td></tr>;
  });
  h += </table>;
  h += <h4>Restricciones</h4><table><tr><th>#</th><th>Tipo</th><th>RHS</th><th>Slack</th><th>Vinculante</th><th>Precio dual (LP)</th></tr>;
  model.A.forEach((r,i)=>{
    const slack = sol.slack? sol.slack[i]||0 : 0;
    const bind = (r.sign==='<=') ? Math.abs(slack) < 1e-7 : '‚Äî';
    h += <tr><td>${i+1}</td><td>${r.sign.replace('==','=')}</td><td>${fmt(r.rhs)}</td><td>${fmt(slack)}</td><td>${bind===true?'S√≠':(bind==='‚Äî'?'‚Äî':'No')}</td><td>${sol.dual? fmt(sol.dual[i]||0): '-'}</td></tr>;
  });
  h += </table>;

  // Gr√°fica si hay 2 variables
  const chartsId = 'graph-2d';
  if(model.V.length===2){
    h += <h4>Regi√≥n factible (2D)</h4><div id="${chartsId}" class="graph"></div>;
  }
  byId('resultados').innerHTML = h;

  if(model.V.length===2){
    graficar2D(model, sol, chartsId);
  }
}

function graficar2D(model, sol, id){
  const ec = echarts.init(byId(id));
  const verts = calcularVertices(model);
  const data = verts.map(p=>[p[0],p[1]]);
  const opt = [sol.x[0]||0, sol.x[1]||0];
  const maxX = Math.max(1, ...data.map(p=>p[0]), opt[0])*1.15;
  const maxY = Math.max(1, ...data.map(p=>p[1]), opt[1])*1.15;
  const option = {
    tooltip:{},
    xAxis:{type:'value', name:model.V[0], min:0, max:maxX},
    yAxis:{type:'value', name:model.V[1], min:0, max:maxY},
    series:[
      {name:'Regi√≥n', type:'line', areaStyle:{}, data:[...data, data[0]||[0,0]], lineStyle:{width:0}},
      {name:'V√©rtices', type:'scatter', data:data},
      {name:'√ìptimo', type:'scatter', data:[opt], symbolSize:14}
    ]
  };
  ec.setOption(option);
}

function calcularVertices(model){
  const rs = model.A.filter(r=> r.rowArr.length>=2);
  const verts=[];
  // ejes
  rs.forEach(r=>{
    const [a,b]=r.rowArr, c=r.rhs;
    if(Math.abs(b)>1e-12){ const y=c/b; if(y>=0) verts.push([0,y]); }
    if(Math.abs(a)>1e-12){ const x=c/a; if(x>=0) verts.push([x,0]); }
  });
  // pares
  for(let i=0;i<rs.length;i++) for(let j=i+1;j<rs.length;j++){
    const [a1,b1]=rs[i].rowArr, [a2,b2]=rs[j].rowArr; const c1=rs[i].rhs, c2=rs[j].rhs;
    const det=a1*b2-a2*b1; if(Math.abs(det)<1e-12) continue;
    const x=(b2*c1-b1*c2)/det; const y=(a1*c2-a2*c1)/det; const p=[x,y];
    if(x>=-1e-9 && y>=-1e-9 && esFactible2D(p, model)) verts.push([Math.max(0,x),Math.max(0,y)]);
  }
  if(!verts.length) return [[0,0]];
  // ordenar y de-duplicar
  const cx=verts.reduce((s,p)=>s+p[0],0)/verts.length, cy=verts.reduce((s,p)=>s+p[1],0)/verts.length;
  verts.sort((A,B)=> Math.atan2(A[1]-cy,A[0]-cx)-Math.atan2(B[1]-cy,B[0]-cx));
  const uniq=[]; const eps=1e-6;
  for(const v of verts){ if(!uniq.some(u=>Math.hypot(u[0]-v[0],u[1]-v[1])<eps)) uniq.push(v); }
  return uniq;
}
function esFactible2D(p, model){
  const [x,y]=p;
  for(const r of model.A){
    const val = (r.rowArr[0]||0)*x + (r.rowArr[1]||0)*y;
    if(r.sign==='<='){ if(val>r.rhs+1e-7) return false; }
    if(r.sign==='>='){ if(val<r.rhs-1e-7) return false; }
    if(r.sign==='=='||r.sign==='='){ if(Math.abs(val-r.rhs)>1e-7) return false; }
  }
  if(x<0||y<0) return false;
  return true;
}

/* ===========================
   6) Flujo principal
   =========================== */
byId('btn-analizar').addEventListener('click', ()=>{
  const raw = entrada.value.trim();
  if(!raw){ alert('Ingresa texto o carga un archivo/imagen.'); return; }
  byId('interpretacion').innerHTML = '<div class="loading"></div> Interpretando‚Ä¶';
  byId('resultados').innerHTML = '<div class="loading"></div> Resolviendo‚Ä¶';
  setTimeout(()=>{
    try{
      // separar m√∫ltiples problemas por cabeceras o separadores
      const bloques = raw.split(/\n\s*(?:---+|Problema\s*\d+|Problem\s*\d+|Ejercicio|Exercise|#\s+\S+)/i).map(s=>s.trim()).filter(Boolean);
      let inter='', res='';
      bloques.forEach((bloque, idx)=>{
        const model = parseUniversal(bloque);
        renderInterpretacion(model);
        const sol = simplexSolve(model);
        renderResultados(model, sol);
        if(idx<bloques.length-1) log('‚Äî Listo un bloque ‚Äî');
      });
    }catch(err){
      byId('resultados').innerHTML = <div class="err">Error: ${err.message}</div>;
      console.error(err);
    }
  }, 50);
});

/* ===========================
   7) Pruebas autom√°ticas (NO tocan tus casos)
   =========================== */
byId('btn-tests').addEventListener('click', ()=>{
  const tests = [
    {
      name:'LP 2D cl√°sico (Max)',
      txt:Z = 80x + 50y; 4x + 3y ‚â§ 240; 2x + y ‚â§ 100; x,y ‚â• 0,
      expectSense:'max'
    },
    {
      name:'Forma que indicaste (‚â• incluido)',
      txt:Z = a x + b y; c x + d y ‚â§ e; f x + g y ‚â• h; x,y ‚â• 0.replace(/a/g,'80').replace(/b/g,'50').replace(/c/g,'4').replace(/d/g,'3').replace(/e/g,'240').replace(/f/g,'2').replace(/g/g,'1').replace(/h/g,'0'),
      expectSense:'max'
    },
    {
      name:'LP estilo .lp minimal',
      txt:Maximize\n  obj: 3 U + 5 H\nSubject To\n  inv: 25 U + 50 H <= 80000\n  risco: 0.5 U + 0.25 H <= 700\n  capU: U <= 1000\nBounds\n  U >= 0\n  H >= 0\nEnd
    },
    {
      name:'MPS free-form b√°sico (min por convenci√≥n MPS)',
      txt:NAME TEST\nROWS\n N OBJ\n L R1\n L R2\nCOLUMNS\n X R1 4 R2 2\n Y R1 3 R2 1\nRHS\n RHS1 R1 240 R2 100\nENDATA
    }
  ];
  logArea.textContent='';
  tests.forEach(t=>{
    try{
      const model = parseUniversal(t.txt);
      if(t.expectSense && model.sense!==t.expectSense) throw new Error(sense esperado ${t.expectSense}, obtenido ${model.sense});
      const sol = simplexSolve(model);
      log(‚úî ${t.name}: OK (Z=${sol.optimalValue?.toFixed?.(4)}));
    }catch(e){
      log(‚úñ ${t.name}: ${e.message});
    }
  });
});
</script>
</body>
</html>
