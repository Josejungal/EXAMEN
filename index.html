<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Calculadora Simplex</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #f4f7f8;
      padding: 20px;
      color: #333;
    }
    .container {
      max-width: 800px;
      margin: auto;
      background: #fff;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(0,0,0,0.1);
    }
    h2 {
      text-align: center;
      color: #007bff;
    }
    label {
      font-weight: bold;
      margin-top: 20px;
      display: block;
    }
    input, textarea, button {
      width: 100%;
      font-size: 16px;
      margin-top: 10px;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #ccc;
      box-sizing: border-box;
    }
    button {
      background: #007bff;
      color: white;
      margin-top: 20px;
      border: none;
    }
    button:hover {
      background: #0056b3;
    }
    pre {
      background: #eef;
      padding: 15px;
      border-left: 5px solid #007bff;
      font-size: 15px;
      white-space: pre-wrap;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Calculadora del Método Simplex</h2>

    <label for="objetivo">Función objetivo:</label>
    <input id="objetivo" placeholder="Ej: max Z = 3x1 + 5x2" />

    <label for="restricciones">Restricciones (una por línea):</label>
    <textarea id="restricciones" rows="6" placeholder="Ej:\n2x1 + x2 <= 18\n2x1 + 3x2 <= 42\n3x1 + x2 <= 24"></textarea>

    <button onclick="resolverSimplex()">Resolver por Método Simplex</button>

    <label>Resultado:</label>
    <pre id="resultado">Esperando datos...</pre>

    <div id="grafico" style="margin-top: 40px;"></div>
  </div>

<script>
function parseExpr(expr) {
  const terms = expr.match(/[+-]?\s*\d*\.?\d*\s*x\d+/g);
  const values = [];
  if (terms) {
    for (let term of terms) {
      const match = term.match(/([+-]?\s*\d*\.?\d*)\s*x(\d+)/);
      let coef = match[1].replace(/\s/g, '');
      coef = coef === '' || coef === '+' ? 1 : coef === '-' ? -1 : parseFloat(coef);
      let index = parseInt(match[2]) - 1;
      values[index] = coef;
    }
  }
  return values;
}

function resolverSimplex() {
  const objInput = document.getElementById('objetivo').value.toLowerCase();
  const resInput = document.getElementById('restricciones').value.trim().split('\n');
  const resultado = document.getElementById('resultado');

  if (!objInput || resInput.length === 0) {
    resultado.textContent = 'Por favor ingresa la función objetivo y al menos una restricción.';
    return;
  }

  let max = objInput.includes('max');
  let obj = parseExpr(objInput);
  let numVars = obj.length;

  let constraints = [];
  let b = [];
  let signs = [];

  for (let linea of resInput) {
    const partes = linea.match(/(.+)(<=|>=|=)(.+)/);
    if (!partes) {
      resultado.textContent = 'Error en la sintaxis de una restricción.';
      return;
    }
    let [izq, signo, der] = partes.slice(1).map(s => s.trim());
    constraints.push(parseExpr(izq));
    b.push(parseFloat(der));
    signs.push(signo);
  }

  for (let i = 0; i < constraints.length; i++) {
    for (let j = 0; j < numVars; j++) {
      if (typeof constraints[i][j] === 'undefined') constraints[i][j] = 0;
    }
  }

  let tableau = constraints.map((fila, i) => {
    let slack = Array(constraints.length).fill(0);
    if (signs[i] === '<=') slack[i] = 1;
    else if (signs[i] === '>=') slack[i] = -1;
    return [...fila, ...slack, b[i]];
  });

  let Z = [...obj, ...Array(constraints.length).fill(0), 0];
  if (!max) Z = Z.map(v => -v);
  tableau.push(Z);

  function pivot(t) {
    const last = t.length - 1;
    const pivotCol = t[last].slice(0, -1).reduce((min, val, i, arr) => val < arr[min] ? i : min, 0);
    if (t[last][pivotCol] >= 0) return t;

    let ratios = t.slice(0, last).map(row => {
      let val = row[pivotCol];
      return val > 0 ? row[row.length - 1] / val : Infinity;
    });

    let pivotRow = ratios.indexOf(Math.min(...ratios));
    if (pivotRow === -1 || ratios[pivotRow] === Infinity) return t;

    const pivotVal = t[pivotRow][pivotCol];
    t[pivotRow] = t[pivotRow].map(v => v / pivotVal);
    for (let i = 0; i <= last; i++) {
      if (i !== pivotRow) {
        let factor = t[i][pivotCol];
        t[i] = t[i].map((v, j) => v - factor * t[pivotRow][j]);
      }
    }
    return t;
  }

  let iteraciones = 0;
  while (tableau[tableau.length - 1].slice(0, -1).some(v => v < 0) && iteraciones++ < 50) {
    tableau = pivot(tableau);
  }

  const Zopt = tableau[tableau.length - 1][tableau[0].length - 1];
  const vars = tableau[0].length - 1;
  const resultados = Array(numVars).fill(0);
  for (let j = 0; j < numVars; j++) {
    let columna = tableau.map(f => f[j]);
    if (columna.filter(x => x === 0).length === columna.length - 1 && columna.includes(1)) {
      let fila = columna.indexOf(1);
      resultados[j] = tableau[fila][vars];
    }
  }

  resultado.textContent = `Z óptimo = ${Zopt.toFixed(2)}\n\nVariables básicas:\n` +
    resultados.map((v, i) => `x${i + 1} = ${v.toFixed(2)}`).join('\n');

  graficarRestricciones(constraints, b, obj, signs, resultados, Zopt);
}

// GRAFICADOR
function evaluarRestriccion(coef, signo, constante, x, y) {
  const val = coef[0] * x + coef[1] * y;
  if (signo === "<=") return val <= constante + 1e-6;
  if (signo === ">=") return val >= constante - 1e-6;
  if (signo === "=")  return Math.abs(val - constante) <= 1e-6;
  return false;
}

function calcularIntersecciones(constraints, b, signs) {
  const puntos = [];

  for (let i = 0; i < constraints.length; i++) {
    for (let j = i + 1; j < constraints.length; j++) {
      const [a1, b1] = constraints[i];
      const [a2, b2] = constraints[j];
      const det = a1 * b2 - a2 * b1;
      if (Math.abs(det) < 1e-8) continue;
      const x = (b[i] * b2 - b[j] * b1) / det;
      const y = (a1 * b[j] - a2 * b[i]) / det;
      if (x >= 0 && y >= 0) {
        let cumple = true;
        for (let k = 0; k < constraints.length; k++) {
          if (!evaluarRestriccion(constraints[k], signs[k], b[k], x, y)) {
            cumple = false;
            break;
          }
        }
        if (cumple) puntos.push([x, y]);
      }
    }
  }

  // cortes con ejes
  for (let i = 0; i < constraints.length; i++) {
    const [a, b1] = constraints[i];
    const rhs = b[i];

    if (a !== 0) {
      const x = rhs / a;
      if (x >= 0 && evaluarRestriccion(constraints[i], signs[i], b[i], x, 0)) puntos.push([x, 0]);
    }
    if (b1 !== 0) {
      const y = rhs / b1;
      if (y >= 0 && evaluarRestriccion(constraints[i], signs[i], b[i], 0, y)) puntos.push([0, y]);
    }
  }

  return puntos;
}

function graficarRestricciones(constraints, b, obj, signs, resultados, z) {
  const grafico = document.getElementById("grafico");
  grafico.innerHTML = "";

  if (obj.length !== 2) {
    grafico.innerHTML = "<i>Gráfica solo disponible para problemas con 2 variables.</i>";
    return;
  }

  const traces = [];
  const xRange = [0, 50];
  const yRange = [0, 50];

  for (let i = 0; i < constraints.length; i++) {
    const [a, b1] = constraints[i];
    const rhs = b[i];
    const x = [0, 50];
    const y = x.map(val => (rhs - a * val) / b1);
    traces.push({
      x,
      y,
      mode: "lines",
      name: `Restricción ${i + 1}`,
      line: { dash: signs[i] === "=" ? "dash" : "solid" }
    });
  }

  const inter = calcularIntersecciones(constraints, b, signs);
  const unicos = Array.from(new Set(inter.map(p => p.join(',')))).map(s => s.split(',').map(Number));
  const ordenados = unicos.sort((a, b) => Math.atan2(a[1], a[0]) - Math.atan2(b[1], b[0]));

  if (ordenados.length > 2) {
    traces.push({
      x: ordenados.map(p => p[0]),
      y: ordenados.map(p => p[1]),
      fill: "toself",
      type: "scatter",
      mode: "lines",
      name: "Área factible",
      fillcolor: "rgba(0,200,100,0.2)",
      line: { color: "green" }
    });
  }

  const [c1, c2] = obj;
  if (c1 !== 0 && c2 !== 0) {
    const x = [0, 50];
    const y = x.map(val => (z - c1 * val) / c2);
    traces.push({
      x,
      y,
      mode: "lines",
      name: "Función Objetivo",
      line: { dash: "dot", color: "black" }
    });
  }

  if (resultados.length >= 2) {
    traces.push({
      x: [resultados[0]],
      y: [resultados[1]],
      mode: "markers+text",
      text: ["Óptimo"],
      textposition: "top center",
      marker: { size: 10, color: "red", symbol: "star" },
      name: "Solución Óptima"
    });
  }

  Plotly.newPlot("grafico", traces, {
    title: "Gráfico del Método Simplex",
    xaxis: { title: "x1", range: xRange },
    yaxis: { title: "x2", range: yRange },
    margin: { t: 40 }
  });
}
</script>

</body>
</html>
