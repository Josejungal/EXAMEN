<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Calculadora Simplex Mejorada (Escalable + Gráfico)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body { font-family: 'Segoe UI', sans-serif; background: #f4f7f8; padding: 20px; color: #333; }
    .container { max-width: 900px; margin: auto; background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 0 15px rgba(0,0,0,0.1); }
    h2 { text-align: center; color: #007bff; }
    label { font-weight: bold; margin-top: 20px; display: block; }
    input, textarea, button { width: 100%; font-size: 16px; margin-top: 10px; padding: 10px; border-radius: 5px; border: 1px solid #ccc; box-sizing: border-box; }
    button { background: #007bff; color: white; margin-top: 20px; border: none; }
    button:hover { background: #0056b3; }
    pre { background: #eef; padding: 15px; border-left: 5px solid #007bff; font-size: 15px; white-space: pre-wrap; margin-top: 20px; }
  </style>
</head>
<body>
<div class="container">
  <h2>Calculadora del Método Simplex (Escalable + Gráfico Mejorado)</h2>

  <label for="objetivo">Función objetivo (ej: max Z = 3x + 5y):</label>
  <input id="objetivo" placeholder="max Z = 3x + 5y" />

  <label for="restricciones">Restricciones (una por línea, ej: 2x + 3y <= 60):</label>
  <textarea id="restricciones" rows="6" placeholder="Ej:\n2x + y <= 18\n2x + 3y <= 42\n3x + y <= 24"></textarea>

  <button onclick="resolverSimplex()">Resolver por Método Simplex</button>

  <label>Resultado y Proceso:</label>
  <pre id="resultado">Esperando datos...</pre>

  <div id="grafico" style="margin-top: 40px;"></div>
</div>

<script>
function parseExpr(expr, variables) {
  const vars = {};
  const terms = expr.match(/[+-]?\s*\d*\.?\d*\s*[a-z]/gi);
  if (terms) {
    for (let term of terms) {
      const match = term.match(/([+-]?\s*\d*\.?\d*)\s*([a-z])/i);
      let coef = match[1].replace(/\s/g, '');
      coef = coef === '' || coef === '+' ? 1 : coef === '-' ? -1 : parseFloat(coef);
      vars[match[2].toLowerCase()] = coef;
    }
  }
  return variables.map(v => vars[v] || 0);
}

function resolverSimplex() {
  const objText = document.getElementById('objetivo').value.toLowerCase();
  const resLines = document.getElementById('restricciones').value.trim().split('\n');
  const resultado = document.getElementById('resultado');
  const grafico = document.getElementById('grafico');
  grafico.innerHTML = '';

  if (!objText.includes('max') && !objText.includes('min')) {
    resultado.textContent = 'Error: la función objetivo debe comenzar con "max" o "min".';
    return;
  }

  const isMax = objText.includes('max');
  const variables = ['x', 'y'];
  const objCoeffs = parseExpr(objText, variables);
  const constraints = [];
  const rhs = [];

  for (let line of resLines) {
    const parts = line.match(/(.+)(<=|>=|=)(.+)/);
    if (!parts) {
      resultado.textContent = `Error en la restricción: "${line}".`;
      return;
    }
    const [left, sign, right] = parts.slice(1).map(s => s.trim());
    constraints.push(parseExpr(left, variables));
    rhs.push(parseFloat(right));
  }

  const pasos = [`Función objetivo: ${objText}`, 'Restricciones:'];
  resLines.forEach((r, i) => pasos.push(`${i + 1}) ${r}`));

  const xRange = [0, 50];
  const traces = [];
  const feasiblePoints = [];

  constraints.forEach((coef, idx) => {
    const [a, b] = coef;
    const c = rhs[idx];
    const x = xRange;
    const y = x.map(val => (c - a * val) / b);
    traces.push({ x, y, mode: 'lines', name: `Restricción ${idx + 1}` });
  });

  for (let i = 0; i < constraints.length; i++) {
    for (let j = i + 1; j < constraints.length; j++) {
      const [a1, b1] = constraints[i];
      const [a2, b2] = constraints[j];
      const c1 = rhs[i], c2 = rhs[j];
      const det = a1 * b2 - a2 * b1;
      if (det !== 0) {
        const x = (c1 * b2 - c2 * b1) / det;
        const y = (a1 * c2 - a2 * c1) / det;
        if (x >= 0 && y >= 0 && constraints.every(([a, b], k) => a * x + b * y <= rhs[k] + 1e-6)) {
          feasiblePoints.push({ x, y });
        }
      }
    }
  }

  if (feasiblePoints.length === 0) {
    resultado.textContent = 'No hay solución factible.';
    return;
  }

  const vertices = feasiblePoints.map(p => [p.x, p.y]);

  traces.push({
    x: vertices.map(p => p[0]),
    y: vertices.map(p => p[1]),
    fill: 'toself',
    fillcolor: 'rgba(0,200,0,0.2)',
    line: { color: 'green' },
    name: 'Región Factible'
  });

  const zValues = feasiblePoints.map(p => objCoeffs[0]*p.x + objCoeffs[1]*p.y);
  const optimalIndex = zValues.indexOf(Math.max(...zValues));
  const optPoint = feasiblePoints[optimalIndex];
  const zOpt = objCoeffs[0]*optPoint.x + objCoeffs[1]*optPoint.y;

  pasos.push('Puntos factibles evaluados:');
  feasiblePoints.forEach((p, i) => {
    const z = objCoeffs[0]*p.x + objCoeffs[1]*p.y;
    pasos.push(`(${p.x.toFixed(2)}, ${p.y.toFixed(2)}) => Z = ${z.toFixed(2)}`);
  });

  pasos.push(`Solución óptima: (${optPoint.x.toFixed(2)}, ${optPoint.y.toFixed(2)}) con Z = ${zOpt.toFixed(2)}`);

  traces.push({
    x: [optPoint.x],
    y: [optPoint.y],
    mode: 'markers+text',
    text: ['Óptimo'],
    textposition: 'top center',
    marker: { size: 12, color: 'red', symbol: 'star' },
    name: 'Óptimo'
  });

  Plotly.newPlot('grafico', traces, {
    title: 'Gráfico Simplex Mejorado',
    xaxis: { title: 'x' },
    yaxis: { title: 'y' },
    dragmode: 'zoom',
    responsive: true,
    showlegend: true
  });

  resultado.textContent = pasos.join('\n');
}
</script>
</body>
</html>
